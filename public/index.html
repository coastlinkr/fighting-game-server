<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mobile Fighter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        body {
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
            height: 100vh;
            height: 100dvh;
        }
        canvas {
            display: block;
            background: linear-gradient(180deg, #87CEEB 0%, #98FB98 100%);
            touch-action: none;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
        }
        .controls {
            position: fixed;
            bottom: 2vh;
            left: 2vw;
            right: 2vw;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
            z-index: 1000;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 1vh;
            pointer-events: auto;
        }
        .move-controls {
            display: flex;
            gap: 1vw;
        }
        .action-controls {
            display: flex;
            flex-direction: column;
            gap: 1vh;
        }
        .control-btn {
            width: 15vw;
            height: 15vw;
            min-width: 60px;
            min-height: 60px;
            max-width: 80px;
            max-height: 80px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            color: #333;
            font-size: 4vw;
            font-weight: bold;
            touch-action: manipulation;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.1s;
        }
        .control-btn:active {
            background: rgba(255, 255, 255, 1);
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .move-btn {
            background: rgba(100, 149, 237, 0.8);
            color: white;
        }
        .move-btn:active {
            background: rgba(100, 149, 237, 1);
        }
        .special-btn {
            background: rgba(255, 69, 0, 0.8);
            color: white;
            font-size: 3vw;
        }
        .special-btn:active {
            background: rgba(255, 69, 0, 1);
        }
        .game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
            text-align: center;
        }
        .menu-content, .lobby-content {
            max-width: 90vw;
            padding: 4vh 2vw;
        }
        .menu-title {
            font-size: 8vw;
            font-weight: bold;
            margin-bottom: 6vh;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .menu-btn {
            display: block;
            width: 80vw;
            max-width: 400px;
            padding: 4vh 4vw;
            margin: 3vh auto;
            border: none;
            border-radius: 2vh;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            font-size: 5vw;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .menu-btn:hover {
            background: linear-gradient(45deg, #45a049, #4CAF50);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        .menu-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .secondary-btn {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }
        .secondary-btn:hover {
            background: linear-gradient(45deg, #1976D2, #2196F3);
        }
        .danger-btn {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }
        .danger-btn:hover {
            background: linear-gradient(45deg, #d32f2f, #f44336);
        }
        .lobby-info {
            font-size: 4vh;
            margin: 4vh 0;
            padding: 2vh;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 1vh;
            border: 2px solid #FFD700;
        }
        .ready-status {
            font-size: 3vh;
            margin: 2vh 0;
            padding: 1vh;
            border-radius: 1vh;
        }
        .ready-true {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
        }
        .ready-false {
            background: rgba(244, 67, 54, 0.3);
            color: #f44336;
        }
        .connection-status {
            position: fixed;
            top: 2vh;
            right: 2vw;
            padding: 1vh 2vw;
            border-radius: 1vh;
            font-size: 3vw;
            font-weight: bold;
            z-index: 3000;
        }
        .connected {
            background: rgba(76, 175, 80, 0.8);
            color: white;
        }
        .disconnected {
            background: rgba(244, 67, 54, 0.8);
            color: white;
        }
        .game-hud {
            position: fixed;
            top: 2vh;
            left: 2vw;
            right: 2vw;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 1000;
            pointer-events: none;
        }
        .health-bar {
            width: 40vw;
            height: 3vh;
            background: rgba(244, 67, 54, 0.8);
            border: 2px solid white;
            border-radius: 1vh;
            overflow: hidden;
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s ease;
        }
        .timer {
            font-size: 6vw;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0, 0, 0, 0.5);
            padding: 1vh 2vw;
            border-radius: 1vh;
        }
    </style>
</head>
<body>
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- Game HUD -->
    <div class="game-hud" id="gameHud" style="display: none;">
        <div>
            <div class="health-bar">
                <div class="health-fill" id="player1Health" style="width: 100%;"></div>
            </div>
            <div style="color: white; font-size: 3vw; margin-top: 1vh;">Player 1</div>
        </div>
        <div class="timer" id="gameTimer">60</div>
        <div>
            <div class="health-bar">
                <div class="health-fill" id="player2Health" style="width: 100%;"></div>
            </div>
            <div style="color: white; font-size: 3vw; margin-top: 1vh;">Player 2</div>
        </div>
    </div>
    
    <!-- Touch Controls -->
    <div class="controls" id="touchControls" style="display: none;">
        <div class="control-group">
            <div class="move-controls">
                <button class="control-btn move-btn" id="leftBtn">‚Üê</button>
                <button class="control-btn move-btn" id="rightBtn">‚Üí</button>
            </div>
        </div>
        <div class="control-group">
            <div class="action-controls">
                <button class="control-btn" id="punchBtn">üëä</button>
                <button class="control-btn" id="kickBtn">ü¶µ</button>
                <button class="control-btn special-btn" id="specialBtn">‚ö°</button>
            </div>
        </div>
    </div>
    
    <!-- Game Overlay (Menu/Lobby) -->
    <div class="game-overlay" id="gameOverlay">
        <!-- Main Menu -->
        <div class="menu-content" id="menuContent">
            <h1 class="menu-title">MOBILE FIGHTER</h1>
            <button class="menu-btn" onclick="createLobby()">üåê Create Lobby</button>
            <button class="menu-btn secondary-btn" onclick="showJoinLobby()">üîó Join Lobby</button>
            <button class="menu-btn secondary-btn" onclick="startPracticeMode()">ü•ä Practice Mode</button>
        </div>
        
        <!-- Lobby Screen -->
        <div class="lobby-content" id="joinLobbyContent" style="display: none;">
            <h2 class="menu-title" style="font-size: 6vw;">JOIN LOBBY</h2>
            <div style="margin: 4vh 0;">
                <input type="text" id="lobbyCodeInput" placeholder="Enter 4-digit code" maxlength="4" 
                       style="width: 200px; padding: 2vh; font-size: 4vh; text-align: center; 
                              background: rgba(255,255,255,0.1); border: 2px solid #FFD700; 
                              border-radius: 1vh; color: white;">
            </div>
            <button class="menu-btn" onclick="joinLobbyFromInput()">Join Game</button>
            <button class="menu-btn danger-btn" onclick="backToMenu()">‚Üê Back to Menu</button>
        </div>
    
    
    <!-- Connection Status -->
    <div class="connection-status disconnected" id="connectionStatus" style="display: none;">
        Connecting...
    </div>

    <!-- Socket.io Client Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>

    <script>
        class FightingGameEngine {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                this.setupNetworking();
                this.setupEventListeners();
                
                // Game state
                this.gameState = 'menu';
                this.gameTime = 60;
                this.gameTimer = null;
                
                // Multiplayer state
                this.isMultiplayer = false;
                this.isHost = false;
                this.lobbyCode = null;
                this.playerId = Math.random().toString(36).substr(2, 9);
                this.playerReady = false;
                this.opponentReady = false;
                this.connected = false;
                
                // Players
                this.players = {};
                this.initializePlayers();
                
                // Input handling
                this.keys = {};
                this.touches = {};
                
                // Game loop
                this.lastTime = 0;
                this.gameLoop = this.gameLoop.bind(this);
                requestAnimationFrame(this.gameLoop);
                
                // Check for lobby join on load
                this.checkForLobbyJoin();
            }
            
            setupCanvas() {
                const resizeCanvas = () => {
                    const dpr = window.devicePixelRatio || 1;
                    const displayWidth = window.innerWidth;
                    const displayHeight = window.innerHeight;
                    
                    this.canvas.width = displayWidth * dpr;
                    this.canvas.height = displayHeight * dpr;
                    this.canvas.style.width = displayWidth + 'px';
                    this.canvas.style.height = displayHeight + 'px';
                    
                    this.ctx.scale(dpr, dpr);
                    
                    this.canvasWidth = displayWidth;
                    this.canvasHeight = displayHeight;
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }
            
            setupNetworking() {
                const serverUrl = window.location.origin;
                this.socket = io(serverUrl);
                
                this.socket.on('connect', () => {
                    console.log('Connected to server');
                    this.connected = true;
                    this.updateConnectionStatus(true);
                });
                
                this.socket.on('disconnect', () => {
                    console.log('Disconnected from server');
                    this.connected = false;
                    this.updateConnectionStatus(false);
                });
                
                this.socket.on('lobby_created', (data) => {
                    console.log('Lobby created:', data);
                    this.lobbyCode = data.lobbyId;
                    this.isHost = true;
                    this.updateLobbyDisplay();
                });
                
                this.socket.on('lobby_joined', (data) => {
                    console.log('Lobby joined:', data);
                    this.lobbyCode = data.lobbyId;
                    this.isHost = false;
                    this.updateLobbyDisplay();
                    document.getElementById('readyBtn').style.display = 'block';
                });
                
                this.socket.on('lobby_updated', (data) => {
                    console.log('Lobby updated:', data);
                    if (data.players) {
                        const player1 = data.players.find(p => p.isHost);
                        const player2 = data.players.find(p => !p.isHost);
                        
                        if (this.isHost) {
                            this.playerReady = player1 ? player1.ready : false;
                            this.opponentReady = player2 ? player2.ready : false;
                        } else {
                            this.playerReady = player2 ? player2.ready : false;
                            this.opponentReady = player1 ? player1.ready : false;
                        }
                        
                        this.updateReadyDisplay();
                        
                        if (data.players.length === 2) {
                            document.getElementById('readyBtn').style.display = 'block';
                        }
                    }
                });
                
                this.socket.on('game_start', (data) => {
                    console.log('Game starting!', data);
                    this.startMultiplayerGame();
                });
                
                this.socket.on('game_input', (data) => {
                    if (data.playerId !== this.socket.id && this.players[2]) {
                        this.processOpponentInput(data);
                    }
                });
                
                this.socket.on('game_update', (data) => {
                    if (data.playerId !== this.socket.id && this.players[2]) {
                        this.players[2].x = data.x;
                        this.players[2].y = data.y;
                        this.players[2].direction = data.direction;
                        this.players[2].currentAction = data.action;
                        this.players[2].health = data.health;
                        this.updateHealthDisplay();
                    }
                });
                
                this.socket.on('player_disconnected', (data) => {
                    console.log('Player disconnected');
                    this.opponentReady = false;
                    this.updateReadyDisplay();
                    if (this.gameState === 'fighting') {
                        this.endGame('Opponent disconnected!');
                    }
                });
                
                this.socket.on('lobby_error', (data) => {
                    alert(data.error || 'Error joining lobby');
                    this.backToMenu();
                });
                
                this.socket.on('game_over', (data) => {
                    this.endGame(data.winner || 'Game Over!');
                });
            }
            
            setupEventListeners() {
                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    e.preventDefault();
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                    e.preventDefault();
                });
                
                // Touch events for buttons
                const buttons = [
                    { id: 'leftBtn', action: 'moveLeft' },
                    { id: 'rightBtn', action: 'moveRight' },
                    { id: 'punchBtn', action: 'punch' },
                    { id: 'kickBtn', action: 'kick' },
                    { id: 'specialBtn', action: 'special' }
                ];
                
                buttons.forEach(button => {
                    const element = document.getElementById(button.id);
                    element.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.touches[button.action] = true;
                    });
                    element.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.touches[button.action] = false;
                    });
                    element.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        this.touches[button.action] = true;
                    });
                    element.addEventListener('mouseup', (e) => {
                        e.preventDefault();
                        this.touches[button.action] = false;
                    });
                });
                
                // Prevent context menu on long press
                document.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Prevent zoom on double tap
                let lastTouchEnd = 0;
                document.addEventListener('touchend', (e) => {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
            }
            
            initializePlayers() {
                this.players = {
                    1: {
                        x: this.canvasWidth * 0.25,
                        y: this.canvasHeight * 0.7,
                        width: 60,
                        height: 100,
                        health: 100,
                        maxHealth: 100,
                        direction: 1,
                        speed: 5,
                        jumpPower: 15,
                        velocityY: 0,
                        onGround: true,
                        currentAction: 'idle',
                        actionTimer: 0,
                        lastAttackTime: 0,
                        color: '#4CAF50'
                    },
                    2: {
                        x: this.canvasWidth * 0.75,
                        y: this.canvasHeight * 0.7,
                        width: 60,
                        height: 100,
                        health: 100,
                        maxHealth: 100,
                        direction: -1,
                        speed: 5,
                        jumpPower: 15,
                        velocityY: 0,
                        onGround: true,
                        currentAction: 'idle',
                        actionTimer: 0,
                        lastAttackTime: 0,
                        color: '#2196F3'
                    }
                };
            }
            
            updateConnectionStatus(connected) {
                const status = document.getElementById('connectionStatus');
                if (connected) {
                    status.textContent = 'Connected';
                    status.className = 'connection-status connected';
                } else {
                    status.textContent = 'Disconnected';
                    status.className = 'connection-status disconnected';
                }
            }
            
            checkForLobbyJoin() {
                const hash = window.location.hash.substring(1);
                if (hash && hash.match(/^\d{4}$/)) {
                    if (this.connected) {
                        this.joinLobby(hash);
                    } else {
                        this.socket.on('connect', () => {
                            this.joinLobby(hash);
                        });
                    }
                }
            }
            
            createLobby() {
                if (!this.connected) {
                    alert('Not connected to server. Please refresh and try again.');
                    return;
                }

                this.gameState = 'lobby';
                document.getElementById('menuContent').style.display = 'none';
                document.getElementById('lobbyContent').style.display = 'block';
                document.getElementById('connectionStatus').style.display = 'block';
                
                document.getElementById('lobbyInfo').innerHTML = `
                    <div style="font-size: 4vh; margin: 2vh 0;">Creating Lobby...</div>
                    <div style="font-size: 2vh; color: #BBB;">Please wait...</div>
                `;
                
                this.socket.emit('create_lobby', {
                    playerId: this.playerId
                });
            }
            
            joinLobby(code) {
                this.gameState = 'lobby';
                document.getElementById('menuContent').style.display = 'none';
                document.getElementById('lobbyContent').style.display = 'block';
                document.getElementById('connectionStatus').style.display = 'block';
                
                document.getElementById('lobbyInfo').innerHTML = `
                    <div style="font-size: 4vh; margin: 2vh 0;">Joining Lobby...</div>
                    <div style="font-size: 2vh; color: #BBB;">Code: ${code}</div>
                `;
                
                this.socket.emit('join_lobby', {
                    lobbyCode: code,
                    playerId: this.playerId
                });
            }
            
            updateLobbyDisplay() {
                if (this.lobbyCode) {
                    const shareUrl = `${window.location.origin}#${this.lobbyCode}`;
                    document.getElementById('lobbyInfo').innerHTML = `
                        <div style="font-size: 6vh; margin: 2vh 0; color: #FFD700;">${this.lobbyCode}</div>
                        <div style="font-size: 3vh; margin: 2vh 0;">Share this code with your friend!</div>
                        <div style="font-size: 2vh; word-break: break-all; color: #BBB;">${shareUrl}</div>
                    `;
                }
            }
            
            updateReadyDisplay() {
                const player1Status = document.getElementById('player1Ready');
                const player2Status = document.getElementById('player2Ready');
                
                player1Status.textContent = `Player 1: ${this.isHost ? (this.playerReady ? 'Ready!' : 'Not Ready') : (this.opponentReady ? 'Ready!' : 'Not Ready')}`;
                player1Status.className = (this.isHost ? this.playerReady : this.opponentReady) ? 'ready-true' : 'ready-false';
                
                player2Status.textContent = `Player 2: ${!this.isHost ? (this.playerReady ? 'Ready!' : 'Not Ready') : (this.opponentReady ? 'Ready!' : 'Not Ready')}`;
                player2Status.className = (!this.isHost ? this.playerReady : this.opponentReady) ? 'ready-true' : 'ready-false';
                
                const readyBtn = document.getElementById('readyBtn');
                readyBtn.textContent = this.playerReady ? 'Not Ready' : 'Ready Up!';
                readyBtn.className = this.playerReady ? 'menu-btn danger-btn' : 'menu-btn';
            }
            
            toggleReady() {
                if (!this.connected || !this.lobbyCode) return;
                
                this.playerReady = !this.playerReady;
                this.socket.emit('player_ready', {
                    ready: this.playerReady,
                    playerId: this.socket.id
                });
                this.updateReadyDisplay();
            }
            
            startPracticeMode() {
                this.gameState = 'fighting';
                this.isMultiplayer = false;
                this.initializePlayers();
                document.getElementById('gameOverlay').style.display = 'none';
                document.getElementById('touchControls').style.display = 'flex';
                document.getElementById('gameHud').style.display = 'flex';
                document.getElementById('connectionStatus').style.display = 'none';
                this.gameTime = 60;
                this.startGameTimer();
            }
            
            startMultiplayerGame() {
                this.gameState = 'fighting';
                this.isMultiplayer = true;
                this.initializePlayers();
                document.getElementById('gameOverlay').style.display = 'none';
                document.getElementById('touchControls').style.display = 'flex';
                document.getElementById('gameHud').style.display = 'flex';
                this.gameTime = 60;
                this.startGameTimer();
            }
            
            startGameTimer() {
                this.gameTimer = setInterval(() => {
                    this.gameTime--;
                    document.getElementById('gameTimer').textContent = this.gameTime;
                    
                    if (this.gameTime <= 0) {
                        this.endGame('Time Up!');
                    }
                }, 1000);
            }
            
        backToMenu() {
            this.gameState = 'menu';
            document.getElementById('menuContent').style.display = 'block';
            document.getElementById('lobbyContent').style.display = 'none';
            document.getElementById('joinLobbyContent').style.display = 'none';
            document.getElementById('gameOverlay').style.display = 'flex';
            document.getElementById('touchControls').style.display = 'none';
            document.getElementById('gameHud').style.display = 'none';
            document.getElementById('connectionStatus').style.display = 'none';
            
            if (this.gameTimer) {
                clearInterval(this.gameTimer);
                this.gameTimer = null;
            }
            
            if (this.lobbyCode) {
                this.socket.emit('leave_lobby', { playerId: this.playerId });
                this.lobbyCode = null;
                this.playerReady = false;
                this.opponentReady = false;
            }
            
            window.location.hash = '';
        }
            
            handleInput(player) {
                const p = this.players[player];
                const now = Date.now();
                
                // Movement controls
                let moving = false;
                
                if (this.isMultiplayer) {
                    // In multiplayer, only control player 1
                    if (player === 1) {
                        if (this.joystickInput.left || this.keys['ArrowLeft'] || this.keys['KeyA']) {
                            p.x -= p.speed;
                            p.direction = -1;
                            moving = true;
                        }
                        if (this.joystickInput.right || this.keys['ArrowRight'] || this.keys['KeyD']) {
                            p.x += p.speed;
                            p.direction = 1;
                            moving = true;
                        }
                        
                        // Jump with up input
                        if (this.joystickInput.up || this.keys['Space'] || this.keys['ArrowUp'] || this.keys['KeyW']) {
                            if (p.onGround) {
                                p.velocityY = -p.jumpPower;
                                p.onGround = false;
                            }
                        }
                        
                        // Crouch with down input
                        p.crouching = this.joystickInput.down || this.keys['ArrowDown'] || this.keys['KeyS'];
                    }
                    // Player 2 is controlled by network input in multiplayer
                } else {
                    // Practice mode - separate controls for each player
                    if (player === 1) {
                        // Player 1 uses WASD and joystick
                        if (this.joystickInput.left || this.keys['KeyA']) {
                            p.x -= p.speed;
                            p.direction = -1;
                            moving = true;
                        }
                        if (this.joystickInput.right || this.keys['KeyD']) {
                            p.x += p.speed;
                            p.direction = 1;
                            moving = true;
                        }
                        
                        if (this.joystickInput.up || this.keys['KeyW']) {
                            if (p.onGround) {
                                p.velocityY = -p.jumpPower;
                                p.onGround = false;
                            }
                        }
                        
                        p.crouching = this.joystickInput.down || this.keys['KeyS'];
                    } else if (player === 2) {
                        // Player 2 uses arrow keys only in practice mode
                        if (this.keys['ArrowLeft']) {
                            p.x -= p.speed;
                            p.direction = -1;
                            moving = true;
                        }
                        if (this.keys['ArrowRight']) {
                            p.x += p.speed;
                            p.direction = 1;
                            moving = true;
                        }
                        
                        if (this.keys['ArrowUp']) {
                            if (p.onGround) {
                                p.velocityY = -p.jumpPower;
                                p.onGround = false;
                            }
                        }
                        
                        p.crouching = this.keys['ArrowDown'];
                    }
                }
                
                // Attack controls
                if (this.isMultiplayer && player === 2) {
                    // Skip attack input for player 2 in multiplayer
                    return;
                }
                
                // Practice mode attack controls
                if (!this.isMultiplayer) {
                    if (player === 1) {
                        // Player 1 attacks with ZXCV and touch buttons
                        if (this.touches['lightPunch'] || this.keys['KeyZ']) {
                            if (now - p.lastAttackTime > 250) {
                                this.performAttack(player, 'lightPunch');
                                p.lastAttackTime = now;
                            }
                        }
                        if (this.touches['heavyPunch'] || this.keys['KeyX']) {
                            if (now - p.lastAttackTime > 350) {
                                this.performAttack(player, 'heavyPunch');
                                p.lastAttackTime = now;
                            }
                        }
                        if (this.touches['lightKick'] || this.keys['KeyC']) {
                            if (now - p.lastAttackTime > 300) {
                                this.performAttack(player, 'lightKick');
                                p.lastAttackTime = now;
                            }
                        }
                        if (this.touches['heavyKick'] || this.keys['KeyV']) {
                            if (now - p.lastAttackTime > 400) {
                                this.performAttack(player, 'heavyKick');
                                p.lastAttackTime = now;
                            }
                        }
                    } else if (player === 2) {
                        // Player 2 attacks with numpad in practice mode
                        if (this.keys['Numpad1']) {
                            if (now - p.lastAttackTime > 250) {
                                this.performAttack(player, 'lightPunch');
                                p.lastAttackTime = now;
                            }
                        }
                        if (this.keys['Numpad2']) {
                            if (now - p.lastAttackTime > 350) {
                                this.performAttack(player, 'heavyPunch');
                                p.lastAttackTime = now;
                            }
                        }
                        if (this.keys['Numpad3']) {
                            if (now - p.lastAttackTime > 300) {
                                this.performAttack(player, 'lightKick');
                                p.lastAttackTime = now;
                            }
                        }
                        if (this.keys['Numpad4']) {
                            if (now - p.lastAttackTime > 400) {
                                this.performAttack(player, 'heavyKick');
                                p.lastAttackTime = now;
                            }
                        }
                    }
                } else {
                    // Multiplayer mode - only player 1 can attack
                    if (player === 1) {
                        if (this.touches['lightPunch'] || this.keys['KeyZ']) {
                            if (now - p.lastAttackTime > 250) {
                                this.performAttack(player, 'lightPunch');
                                p.lastAttackTime = now;
                            }
                        }
                        if (this.touches['heavyPunch'] || this.keys['KeyX']) {
                            if (now - p.lastAttackTime > 350) {
                                this.performAttack(player, 'heavyPunch');
                                p.lastAttackTime = now;
                            }
                        }
                        if (this.touches['lightKick'] || this.keys['KeyC']) {
                            if (now - p.lastAttackTime > 300) {
                                this.performAttack(player, 'lightKick');
                                p.lastAttackTime = now;
                            }
                        }
                        if (this.touches['heavyKick'] || this.keys['KeyV']) {
                            if (now - p.lastAttackTime > 400) {
                                this.performAttack(player, 'heavyKick');
                                p.lastAttackTime = now;
                            }
                        }
                    }
                }
                
                // Update action state
                if (p.actionTimer <= 0) {
                    if (moving) {
                        p.currentAction = 'walking';
                    } else if (p.crouching) {
                        p.currentAction = 'crouching';
                    } else {
                        p.currentAction = 'idle';
                    }
                }
                
                // Boundary check
                p.x = Math.max(p.width/2, Math.min(this.canvasWidth - p.width/2, p.x));
            }            
            performAttack(playerNum, attackType) {
                const attacker = this.players[playerNum];
                const target = this.players[playerNum === 1 ? 2 : 1];
                
                attacker.currentAction = attackType;
                
                // Set action timer based on attack type
                const actionTimers = {
                    lightPunch: 20,
                    heavyPunch: 30,
                    lightKick: 25,
                    heavyKick: 35
                };
                attacker.actionTimer = actionTimers[attackType] || 30;
                
                // Check if attack hits
                const distance = Math.abs(attacker.x - target.x);
                const attackRanges = {
                    lightPunch: 70,
                    heavyPunch: 80,
                    lightKick: 85,
                    heavyKick: 95
                };
                const attackRange = attackRanges[attackType] || 80;
                
                if (distance < attackRange) {
                    const damages = {
                        lightPunch: 5,
                        heavyPunch: 10,
                        lightKick: 7,
                        heavyKick: 12
                    };
                    const damage = damages[attackType] || 10;
                    
                    target.health -= damage;
                    target.health = Math.max(0, target.health);
                    
                    // Knockback
                    const knockbacks = {
                        lightPunch: 10,
                        heavyPunch: 20,
                        lightKick: 15,
                        heavyKick: 25
                    };
                    const knockback = knockbacks[attackType] || 15;
                    
                    target.x += attacker.direction * knockback;
                    target.x = Math.max(target.width/2, Math.min(this.canvasWidth - target.width/2, target.x));
                    
                    this.updateHealthDisplay();
                    
                    if (target.health <= 0) {
                        if (this.isMultiplayer) {
                            this.socket.emit('game_over', { winner: `Player ${playerNum}` });
                        }
                        this.endGame(`Player ${playerNum} Wins!`);
                    }
                }
            }
            
            processOpponentInput(data) {
                const opponent = this.players[2];
                if (!opponent) return;
                
                // Process movement
                if (data.moveLeft) {
                    opponent.x -= opponent.speed;
                    opponent.direction = -1;
                }
                if (data.moveRight) {
                    opponent.x += opponent.speed;
                    opponent.direction = 1;
                }
                
                // Process actions
                if (data.action) {
                    opponent.currentAction = data.action;
                    opponent.actionTimer = data.action === 'special' ? 60 : (data.action === 'kick' ? 40 : 30);
                    
                    // Check if the attack hits player 1
                    const distance = Math.abs(opponent.x - this.players[1].x);
                    const attackRange = data.action === 'special' ? 120 : 80;
                    
                    if (distance < attackRange) {
                        const damage = data.action === 'special' ? 25 : (data.action === 'kick' ? 15 : 10);
                        this.players[1].health -= damage;
                        this.players[1].health = Math.max(0, this.players[1].health);
                        this.updateHealthDisplay();
                        
                        if (this.players[1].health <= 0) {
                            this.socket.emit('game_over', { winner: 'Player 2' });
                            this.endGame('Player 2 Wins!');
                        }
                    }
                }
            }
            
            updatePhysics(player) {
                const p = this.players[player];
                
                // Gravity
                p.velocityY += 0.8;
                p.y += p.velocityY;
                
                // Ground collision
                const groundY = this.canvasHeight * 0.7;
                if (p.y >= groundY) {
                    p.y = groundY;
                    p.velocityY = 0;
                    p.onGround = true;
                }
                
                // Action timer
                if (p.actionTimer > 0) {
                    p.actionTimer--;
                }
            }
            
            updateHealthDisplay() {
                const player1Health = document.getElementById('player1Health');
                const player2Health = document.getElementById('player2Health');
                
                if (player1Health && this.players[1]) {
                    const healthPercentage = (this.players[1].health / this.players[1].maxHealth) * 100;
                    player1Health.style.width = healthPercentage + '%';
                }
                
                if (player2Health && this.players[2]) {
                    const healthPercentage = (this.players[2].health / this.players[2].maxHealth) * 100;
                    player2Health.style.width = healthPercentage + '%';
                }
            }
            
            endGame(message) {
                if (this.gameTimer) {
                    clearInterval(this.gameTimer);
                    this.gameTimer = null;
                }
                
                alert(message);
                this.backToMenu();
            }
            
            drawPlayer(player) {
                const p = this.players[player];
                if (!p) return;
                
                this.ctx.save();
                
                // Draw shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.ellipse(p.x, this.canvasHeight * 0.7 + 10, p.width * 0.6, 10, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw player
                this.ctx.fillStyle = p.color;
                this.ctx.fillRect(p.x - p.width/2, p.y - p.height, p.width, p.height);
                
                // Draw face
                this.ctx.fillStyle = '#FFE0BD';
                this.ctx.fillRect(p.x - p.width/3, p.y - p.height + 10, p.width * 0.66, p.height * 0.3);
                
                // Draw eyes
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(p.x - p.width/4, p.y - p.height + 20, 5, 5);
                this.ctx.fillRect(p.x + p.width/8, p.y - p.height + 20, 5, 5);
                
                // Draw action effects
                if (p.currentAction === 'punch' && p.actionTimer > 20) {
                    this.ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
                    this.ctx.fillRect(p.x + (p.direction * p.width/2), p.y - p.height/2, p.direction * 30, 20);
                } else if (p.currentAction === 'kick' && p.actionTimer > 30) {
                    this.ctx.fillStyle = 'rgba(255, 165, 0, 0.7)';
                    this.ctx.fillRect(p.x + (p.direction * p.width/2), p.y - p.height/3, p.direction * 40, 25);
                } else if (p.currentAction === 'special' && p.actionTimer > 40) {
                    this.ctx.fillStyle = 'rgba(255, 0, 255, 0.8)';
                    this.ctx.fillRect(p.x + (p.direction * p.width/2), p.y - p.height + 10, p.direction * 60, p.height - 20);
                }
                
                this.ctx.restore();
            }
            
            sendMultiplayerUpdate() {
                if (this.isMultiplayer && this.connected && this.gameState === 'fighting') {
                    // Send current input state
                    const inputData = {
                        moveLeft: this.keys['ArrowLeft'] || this.keys['KeyA'] || this.touches['moveLeft'],
                        moveRight: this.keys['ArrowRight'] || this.keys['KeyD'] || this.touches['moveRight'],
                        jump: this.keys['Space'] || this.keys['ArrowUp'] || this.keys['KeyW'],
                        action: this.players[1].currentAction !== 'idle' ? this.players[1].currentAction : null
                    };
                    
                    // Send input if any action is happening
                    if (inputData.moveLeft || inputData.moveRight || inputData.jump || inputData.action) {
                        this.socket.emit('game_input', inputData);
                    }
                    
                    // Also send periodic state updates
                    const stateData = {
                        x: this.players[1].x,
                        y: this.players[1].y,
                        direction: this.players[1].direction,
                        action: this.players[1].currentAction,
                        health: this.players[1].health
                    };
                    this.socket.emit('game_update', stateData);
                }
            }
            
            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
                
                if (this.gameState === 'fighting') {
                    // Draw background
                    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvasHeight);
                    gradient.addColorStop(0, '#87CEEB');
                    gradient.addColorStop(1, '#98FB98');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
                    
                    // Draw ground
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.fillRect(0, this.canvasHeight * 0.7, this.canvasWidth, this.canvasHeight * 0.3);
                    
                    // Draw players
                    this.drawPlayer(1);
                    this.drawPlayer(2);
                }
            }
            
            gameLoop(currentTime) {
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                if (this.gameState === 'fighting') {
                    // Handle input
                    this.handleInput(1);
                    if (!this.isMultiplayer) {
                        this.handleInput(2);
                    }
                    
                    // Update physics
                    this.updatePhysics(1);
                    this.updatePhysics(2);
                }
                
                // Render
                this.render();
                
                // Send multiplayer updates
                if (this.gameState === 'fighting' && this.isMultiplayer) {
                    this.sendMultiplayerUpdate();
                }
                
                // Continue loop
                requestAnimationFrame(this.gameLoop);
            }
        }

        // Initialize game instance
        let game;

        // Global function to create a lobby
        window.createLobby = function() {
            if (game && game.connected) {
                game.createLobby();
            } else {
                alert('Game not connected. Please refresh and try again.');
            }
        }
        
        // Global function to start practice mode
        window.startPracticeMode = function() {
            if (game) {
                game.startPracticeMode();
            }
        }
        
        // Global function to toggle ready status
        window.toggleReady = function() {
            if (game) {
                game.toggleReady();
            }
        }
        
        // Global function to go back to menu
        window.backToMenu = function() {
            if (game) {
                game.backToMenu();
            }
        }
        
        // Global function to show join lobby screen
        window.showJoinLobby = function() {
            if (game) {
                document.getElementById('menuContent').style.display = 'none';
                document.getElementById('joinLobbyContent').style.display = 'block';
                document.getElementById('lobbyCodeInput').value = '';
                document.getElementById('lobbyCodeInput').focus();
            }
        }
        
        // Global function to join lobby from input
        window.joinLobbyFromInput = function() {
            if (game) {
                const code = document.getElementById('lobbyCodeInput').value.trim();
                if (code && code.match(/^\d{4}$/)) {
                    game.joinLobby(code);
                } else {
                    alert('Please enter a valid 4-digit code');
                }
            }
        }
        
        // Initialize game when page loads
        window.addEventListener('load', () => {
            game = new FightingGameEngine();
            // Make game globally accessible for debugging
            window.game = game;
        });
        
</script>
</body>
</html>
